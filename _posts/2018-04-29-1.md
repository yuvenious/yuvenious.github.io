---
layout: post
title:  "Race Segregation by using Agent-based modeling (에이전트 기반 모델링을 이용한 인종 주거격리 현상 시뮬레이션)"
date:   2018-04-29 16:39:47 +0100
categories: blog
tags:
- simulation
- agent-based modeling
- 에이전트 기반 모델링
- 시뮬레이션
- 모델링
- python
- 파이썬
- 데이터시각화
---

Introduction
--------
source: "An introduction to agent-based models: simulating segregation with Python" https://www.binpress.com/tutorial/introduction-to-agentbased-models-an-implementation-of-schelling-model-in-python/144

사회과학의 연구 주제 중 하나인, *Race Segregation*(인종 주거격리)을 **Agent-Based Modeling**(에이전트 기반 모델링, hereinafter, ABM)로 구현해보았습니다.

**본 모델링에 python을 사용한 이유는?**

*Object-Oriented(객체지향)의 특성이 ABM의 본질과 궁합이 매우 좋기 때문* 입니다.

(본 포스팅에 제시된 내용은 source에 나온 방법을 대체로 따라갔으나, 필자의 입맛에 따라 일부 코드는 수정하였습니다.)

Background
---------
인종 주거격리 현상은 아래 한장의 인종 분포도로 요약 가능합니다.

(*백인/흑인/아시아/히스패닉 등 인종에 따라 뚜렷한 주거격리 현상이 나타납니다.*)
![1](https://i.huffpost.com/gen/1321377/original.jpg)
source: https://www.huffingtonpost.com/2013/08/27/map-segregation-america-race_n_3824693.html

※ 한국처럼 대부분의 인구가 단일민족으로 이루어진 경우, 지금 당장은 큰 관심사가 아닐 수 있습니다. 하지만 한국사회도 시간이 흐를수록 점점 더 다원화될 것이라는 점을 고려하면, 본 주제의 중요도는 더욱더 높아진다고 생각합니다.

- 작동 원리
==========
사람들이 주변 환경에 만족(혹은 불만족)하고, 지금 집에 머물거나 이사를 가는 행위는 아주 복잡한 요소들의 상호작용(접근성, 소음, 일자리, 교육, 환경 등)이라고 볼 수 있습니다. 하지만 그 모든 요소들을 모델링하는 것을 불가능하므로 본 모델은 아래와 같이 아주 간단한 원리로만 작동합니다.
1. 주변 이웃을 살펴본 후 인종 유사도(race similarity)를 따져본다.
2. 유사도와 일정 조건(similarity threshold) 값에 따라 머물거나, 이사를 간다.

(모델링은 늘 현실세계에서 일어나는 일을 manageable한 수준으로 압축해야 합니다.)

- Decision Variables (Determinants)
==========
다음 변수들은 본 모델의 결과에 큰 영향을 줄 것으로 예상됩니다.
1. similarity threshold: Agents의 행동을 결정짓는 가장 중요한 요소입니다. 기본적으로 모든 agents들은 인종 유사도가 높으면 현재 위치에 머물고, 낮으면 빈집으로 이사를 가게 됩니다. 다시 말해, 이 기준값이 높으면 높을수록, 다른 인종이 내 주변에 많이 사는 것을 못 견디는 것입니다. (따라서 tolerance의 반대 개념이라고 볼 수 있습니다.)
2. empty house ratio: 빈 집이 많다는 것은 만족도가 낮을 때 이사갈 수 있는 집이 충분히 있다는 것을 의미합니다.

이외에도 몇가지 input parameters들(도시의 크기 등)이 있으나, 결과에 미치는 영향력은 미미할 것으로 판단해봅니다.

- 결과
==========
코드를 올리기 전에, 이 모델링과 시뮬레이션이 어떤 결과를 향해가는 것인지부터 제시해보자면, 다음과 같습니다.
![download](https://user-images.githubusercontent.com/37578231/39407743-35f3da46-4bcb-11e8-9fc1-241f8d5f506f.png)
시간이 흐르면 흐를수록 같은 인종끼리 일종의 군집을 형성하게 되고, 그 경계선은 빈집으로 이루어집니다(...좀 소름)

```python
import matplotlib.pyplot as plt
import numpy as np
import itertools
import random
import copy
# for simplicity, neighbors -> neibors

class Schelling:
    def __init__(self, width, height, empty_ratio, sim_th, races = 2):
        self.width = width
        self.height = height
        self.races = races
        self.empty_ratio = empty_ratio
        self.sim_th = sim_th
        self.empty_houses = []
        self.agents = {}
        self.n_update = 0
        self.frac_satis = 0.0      
    def populate(self):
        #1. create grid and shuffle
        self.grid = list(itertools.product(range(self.width), range(self.height)))
        random.shuffle(self.grid)
        #2. number of empty houses
        self.n_empty = int(self.empty_ratio * len(self.grid))
        #3. empty houses
        self.empty_houses = self.grid[:self.n_empty]
        #4. remaining houses
        self.remaining_houses = self.grid[self.n_empty:]
        #5. assign people
        self.houses_by_race = [self.remaining_houses[i::self.races] for i in range(self.races)]
        #6. agents
        for i in range(self.races):
            d_race = dict(zip(self.houses_by_race[i], [i]*len(self.houses_by_race[i])))
            self.agents = {**self.agents,**d_race}

    def is_satisfied(self, x, y, verbose = False):
        loc = (x, y)
        if loc in city.empty_houses:
            return np.nan
        else:
            race = self.agents[loc]
            # search neibors' grid
            arr = np.array([[0,1], [1,0], [0,-1], [-1,0],
                            [-1,-1], [1,1], [-1,1], [1,-1]])
            # If any inside grid,
            cond0 = loc[0] not in [0, self.width-1]
            cond1 = loc[1] not in [0, self.height-1]
            cond = cond0 & cond1
            if cond:
                neibors = arr + loc
            # otherwise,
            else:
                neibors = []
                for i, val in enumerate(arr):
                    neibor = np.array(loc) + val
                    # shouldn't be negative
                    not_negative = not np.any(neibor < 0)
                    # should be inside the city boundary
                    inbound_width = neibor[0] <= self.width-1
                    inbound_height = neibor[1] <= self.height-1
                    if (not_negative & inbound_width & inbound_height):
                        neibors.append(neibor)
                neibors = np.array(neibors)
            # collect neibors' race
            neibors_race = []
            for i, val in enumerate(neibors):
                # count unless neibor is empty:
                loc = tuple(val)
                if loc not in self.empty_houses:
                    neibors_race.append(self.agents[loc])
            # compare (True or False)
            if len(neibors_race) == 0: #when every neibor is emtpy houses
                return True # they will be satisfied
            else:
                neibors_race = np.array(neibors_race) == race
                # return proportion of True is larger than threshold
                proportion = np.count_nonzero(neibors_race)/len(neibors_race)
                if verbose:
                    print(neibors_race, proportion)
                    return proportion > self.sim_th
                else:
                    return proportion > self.sim_th

    def update(self):
        # collect disatisfied agents
        disat_agents = {}
        for loc, race in self.agents.items():
            if not self.is_satisfied(loc[0], loc[1]):
                disat_agents[loc] = race
        # agents to be moved
        if len(list(disat_agents)) >= self.n_empty: #if dissatisfied agents are larger than empty houses
            old_locs = random.sample(list(disat_agents), self.n_empty)
            disat_agents_move = {old_loc: disat_agents[old_loc] for old_loc in old_locs}
            # define new agents in new houses (former empty houses)
            new_agents = dict(zip(self.empty_houses, disat_agents_move.values()))
            # update empty houses, after agents moved out
            self.empty_houses = list(disat_agents_move.keys())
            # delete agents in the old locations
            [self.agents.pop(key) for key in disat_agents_move.keys()]
            # update agents, after agents moved in
            self.agents = {**self.agents, **new_agents}

        else: # if disatisfied agents are smaller than empty houses (every agent can now move)
            # choose random empty houses for agents to move in
            new_locs = random.sample(self.empty_houses, len(disat_agents))
            # define new agents in new house
            new_agents = dict(zip(new_locs, disat_agents.values()))
            # update empty houses
            remaining_empty = list(filter(lambda x: x not in new_locs, self.empty_houses))
            self.empty_houses = list(disat_agents.keys()) + remaining_empty
            # delete agents in the old locations
            [self.agents.pop(key) for key in disat_agents.keys()]
            # update agents, after agents moved in
            self.agents = {**self.agents, **new_agents}

        # evaluate the result
        self.satis_agents = {}
        for loc, race in self.agents.items():
            if self.is_satisfied(loc[0], loc[1]):
                self.satis_agents[loc] = race
        self.frac_satis = len(self.satis_agents)/len(self.agents)
        self.n_update += 1        

    def simulation(self, threshold = 0.8):
        while self.frac_satis < threshold:
            self.update()
            if self.n_update > 100:
                print("100 iterations reached.")
                break
        print("%s iterations completed"%city.n_update)        

    def plot(self):
        cmap = {0: "blue", 1: "red"}
        for loc, race in self.agents.items():
            plt.scatter(loc[0], loc[1], s = 50, color = cmap[race], alpha = 0.5)
        if self.n_update != 0:
            for loc, race in self.satis_agents.items():
                plt.scatter(loc[0], loc[1], s = 65, color = cmap[race], alpha = 1)
        plt.axis("off")
        plt.title("Satisfaction Fraction: %s\nupdate(s):%s"%(np.round(self.frac_satis, 2), self.n_update))        
```

코드를 테스트해보겠습니다. 맨 윗줄부터:
1. 도시 생성
- 가로 20, 세로 20, 빈집 15%, threshold = 0.3
2. agents 생성
3. simulation
4. plot

```python

# test
city = Schelling(20, 20, 0.15, 0.3)
city.populate()
city.simulation()
city.plot()

    1 iterations completed
```
![output_2_1](https://user-images.githubusercontent.com/37578231/39408317-bc0afe26-4bd4-11e8-8fed-5cf8184c6e4a.png)

test결과입니다. threshold값이 0.3인지라 뚜렷한 경계는 생기지 않네요. 다채롭게, 조화롭게 살고 있는 상태!

**※threshold는 *"같은 인종의 비율이 어느 정도가 되어야 만족하는가?"* 에 대한 기준점이라고 볼 수 있습니다.** 즉, 이 값이 0.3이면, 30%만 같은 인종이고, 70%가 다른 인종이라도 만족하고 산다는 의미죠. 하지만 이 값이 반대로 0.7이라면? 70%이상이 나랑 같은 인종이어야만 만족하고 산다는 의미로, tolerance는 낮아진다고  볼 수 있습니다.

```python
# test
tolerance = [0.2,0.3,0.4,0.5,0.6,0.7]
plt.figure(figsize = (12, 8))
for i, val in enumerate(tolerance):
    city = Schelling(20, 20, 0.15, val)
    city.populate()
    city.simulation()
    plt.subplot(2,3,i+1)
    city.plot()

    1 iterations completed
    1 iterations completed
    2 iterations completed
    7 iterations completed
    9 iterations completed
    21 iterations completed
```

![output_3_1](https://user-images.githubusercontent.com/37578231/39408319-bfc61be0-4bd4-11e8-8d8d-6ee00fb74856.png)

threshold값을 0.2(왼쪽 위)부터 0.7(오른쪽 아래)까지 서서히 증가시켜보았습니다. 높아질수록 이사를 해야하는 횟수가 점점 많아지는데, 그만큼 인종 격리현상은 더 심해지는 것을 볼 수 있습니다.

```python
city = Schelling(20, 20, 0.25, 0.7)
city.populate()
plt.figure(figsize = (20,20))
for i in range(25):
    plt.subplot(5,5,i+1)
    city.plot()
    city.update()

```
![output_4_0](https://user-images.githubusercontent.com/37578231/39408320-c00e3f10-4bd4-11e8-8e7e-957b3d203ed3.png)

코드를 소개하기 전의 그림과 동일합니다.
